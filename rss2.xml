<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>北带河</title>
    <link>http://example.com/</link>
    
    <atom:link href="http://example.com/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>Attention is all you need</description>
    <pubDate>Sun, 29 Jan 2023 13:58:01 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>CS106L</title>
      <link>http://example.com/2023/01/29/CS106L-1/</link>
      <guid>http://example.com/2023/01/29/CS106L-1/</guid>
      <pubDate>Sun, 29 Jan 2023 13:58:01 GMT</pubDate>
      
      
      
      
      
      
      <comments>http://example.com/2023/01/29/CS106L-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title></title>
      <link>http://example.com/2023/01/29/CS106L/</link>
      <guid>http://example.com/2023/01/29/CS106L/</guid>
      <pubDate>Sun, 29 Jan 2023 13:57:36 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;CS106L&quot;&gt;&lt;a href=&quot;#CS106L&quot; class=&quot;headerlink&quot; title=&quot;CS106L&quot;&gt;&lt;/a&gt;CS106L&lt;/h1&gt;&lt;h2 id=&quot;Lec0-Introduction&quot;&gt;&lt;a href=&quot;#Lec0-Introduction&quot; c</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="CS106L"><a href="#CS106L" class="headerlink" title="CS106L"></a>CS106L</h1><h2 id="Lec0-Introduction"><a href="#Lec0-Introduction" class="headerlink" title="Lec0: Introduction"></a>Lec0: Introduction</h2><blockquote><p>c++</p><p>qt</p></blockquote><h2 id="Lec1-Streams-I"><a href="#Lec1-Streams-I" class="headerlink" title="Lec1: Streams_I"></a>Lec1: Streams_I</h2><h3 id="The-idea-behind-streams"><a href="#The-idea-behind-streams" class="headerlink" title="The idea behind streams"></a>The idea behind streams</h3><blockquote><p>A stream is an <strong>abstraction</strong> for input&#x2F;output</p><p>You can write <strong>any particular</strong> type to stream</p><p>input from user as <strong>string</strong></p><p>output to user as <strong>string</strong></p><p>compute as <strong>object</strong></p></blockquote><h3 id="Types-of-streams"><a href="#Types-of-streams" class="headerlink" title="Types of streams"></a>Types of streams</h3><blockquote><p>&#x3D;&#x3D;output streams&#x3D;&#x3D;: can only <strong>receive</strong> data</p><p>insertion operator: &lt;&lt;</p><p><code>&lt;&lt;</code> converts data to string and <strong>sends</strong> to stream</p></blockquote><blockquote><p>&#x3D;&#x3D;input streams&#x3D;&#x3D;: can only give you data</p><p>extraction operator: &gt;&gt;</p><p><code>&gt;&gt;</code> gets data from stream as a string and converts it into the appropriate type</p></blockquote><table><thead><tr><th align="center">4</th><th align="center">2<code>position1</code></th><th></th><th align="center">1</th><th align="center">3</th><th align="center">4<code>position2</code></th><th align="center">\n<code>position3</code></th><th></th></tr></thead></table><ul><li>position1: Extracting an integer will read as many characters as possible from the stream.</li><li>position2: Extracting again will skip over any whitespace when reading the next integer.</li><li>position3: When no more data is left, the fail bit will be set to true and input.fail() will return true.</li></ul><p></p><blockquote><p>Reading into a string using &gt;&gt; will only read a single word, not the whole line.</p><p>To read a whole line, use <code>getline(istream&amp; stream, string&amp; line)</code></p><p>example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">readHaikuLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create our ifstream and make it open the file</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;../res/haiku.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This will store the lines as we get them form the stream</span></span><br><span class="line">    string line;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        std::<span class="built_in">getline</span>(input, line);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If input is in a fail state, either a value couldn&#x27;t</span></span><br><span class="line">        <span class="comment">// be converted, or we are at the end of the file.</span></span><br><span class="line">        <span class="keyword">if</span>(input.<span class="built_in">fail</span>())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>haiku.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Space is limited</span><br><span class="line">Haiku make it difficult</span><br><span class="line">To finish what you</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Word read: Space</span><br><span class="line">Word read: is</span><br><span class="line">Word read: limited</span><br><span class="line">Word read: Haiku</span><br><span class="line">Word read: make</span><br><span class="line">Word read: it</span><br><span class="line">Word read: difficult</span><br><span class="line">Word read: To</span><br><span class="line">Word read: finish</span><br><span class="line">Word read: what</span><br><span class="line">Word read: you</span><br></pre></td></tr></table></figure><p>next let’s do some tests on cin and cout</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input: </p><p>41</p><p>output: </p><p>4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    cout &lt;&lt; a+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>input:</p><p>41</p><p>output:</p><p>53</p><p>the ascii code of 1 is 49(0d)</p></blockquote><h2 id="Lec2-Streams-II"><a href="#Lec2-Streams-II" class="headerlink" title="Lec2: Streams_II"></a>Lec2: Streams_II</h2><h3 id="Stream-Internals"><a href="#Stream-Internals" class="headerlink" title="Stream Internals"></a>Stream Internals</h3><blockquote><p>Writing to a console&#x2F;file is a <strong>slow</strong> operation</p><p>So we can use a temporary buffer&#x2F;array to accumulate characters</p><p><u>When buffer is full, write out all contents of the buffer to the output device at once.</u></p><p><strong>↑</strong> This process is flushing the stream</p></blockquote><blockquote><p>The internal sequence of data stored in a stream is called a <strong>buffer</strong>. </p><p>Istreams use them to store data we haven’t used yet.</p><p>Ostreams use them to store data they haven’t passed along yet.</p><p>&#x3D;&#x3D;Flushing the Buffer&#x3D;&#x3D;</p><p>if we want to force the contents in buffer to their destination, we can flush.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream.<span class="built_in">flush</span>(ch); <span class="comment">// use by default </span></span><br><span class="line"></span><br><span class="line">stream &lt;&lt; std::flush; <span class="comment">// use if you are printing </span></span><br><span class="line"></span><br><span class="line">stream &lt;&lt; std::endl; <span class="comment">// use if you want a newline</span></span><br></pre></td></tr></table></figure><p>the endl just newline and flush</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stream &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; std::flush;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Streams have four bits to give us information about their state:</p><ul><li>Good bit</li><li>EOF bit</li><li>Fail bit</li><li>Bad bit</li></ul></blockquote><h3 id="Stream-Shortcuts"><a href="#Stream-Shortcuts" class="headerlink" title="Stream Shortcuts"></a>Stream Shortcuts</h3><blockquote><p>The &lt;&lt; and &gt;&gt; operators are not magic, they are actually functions!</p><p>The &lt;&lt; and &gt;&gt; operators <strong>return the stream</strong> passed as their left argument.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span> &lt;&lt; <span class="number">23</span> &lt;&lt; <span class="string">&quot;world&quot;</span>;</span><br><span class="line">(((std::cout &lt;&lt; <span class="string">&quot;hello&quot;</span>) &lt;&lt; <span class="number">23</span>) &lt;&lt; <span class="string">&quot;world&quot;</span>);</span><br><span class="line">(((std::cout) &lt;&lt; <span class="number">23</span>) &lt;&lt; <span class="string">&quot;world&quot;</span>);</span><br><span class="line">((std::cout &lt;&lt; <span class="number">23</span>) &lt;&lt; <span class="string">&quot;world&quot;</span>);</span><br><span class="line">((std::cout) &lt;&lt; <span class="string">&quot;world&quot;</span>);</span><br><span class="line">(std::cout &lt;&lt; <span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h3 id="Stream-Manipulators"><a href="#Stream-Manipulators" class="headerlink" title="Stream Manipulators"></a>Stream Manipulators</h3><blockquote><iomanip><p>Common: </p><p>​● endl inserts a newline and flushes the stream </p><p>​● ws skips all whitespace until it finds another char </p><p>​● boolalpha prints “true” and “false” for bools </p><p>Numeric: </p><p>​● hex: prints numbers in hex </p><p>​● setprecision: adjusts the precision numbers print with </p><p>Padding: </p><p>​● setw pads output </p><p>​● setfill fills padding with character</p></blockquote><h3 id="StringStream"><a href="#StringStream" class="headerlink" title="StringStream"></a>StringStream</h3><blockquote><sstream><p>Sometimes we want to be able to treat a string like a stream. </p><p>Useful scenarios: </p><p>​● Converting between data types </p><p>​● Tokenizing a string</p></blockquote><h2 id="Lec3-Sequential-Containers"><a href="#Lec3-Sequential-Containers" class="headerlink" title="Lec3: Sequential Containers"></a>Lec3: Sequential Containers</h2><h3 id="getline-vs-cin"><a href="#getline-vs-cin" class="headerlink" title="getline() vs cin"></a>getline() vs cin</h3><blockquote><p>using <code>getline()</code> after <code>cin</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> number;</span><br><span class="line">string name;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; number;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;number is: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">getline</span>(cin,name);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name is: &quot;</span> &lt;&lt; name;</span><br></pre></td></tr></table></figure><hr><p>input:</p><p><code>21/n</code></p><hr><p>output:</p><p><code>21</code></p><p><code>number is: 21</code></p><p><code>name is:</code> </p><hr><p>the reason why i cannot input <u>name</u> is that there already have <u>‘&#x2F;n’</u> character in <u>istream</u> so getline() will identify it and end.</p><p>solution:</p><p>using <code>cin &gt;&gt; ws</code> to ignore or <code>cin.ignore(a,h)</code></p></blockquote><h3 id="Useful-Aside"><a href="#Useful-Aside" class="headerlink" title="Useful Aside"></a>Useful Aside</h3><blockquote><p>struct</p><p>STL</p></blockquote><h3 id="Sequence-Containers"><a href="#Sequence-Containers" class="headerlink" title="Sequence Containers"></a>Sequence Containers</h3><ul><li>std::vector&lt;T&gt;</li><li>std::list&lt;T&gt;</li><li>std::deque&lt;T&gt;</li></ul><blockquote><p>&#x3D;&#x3D;vector&#x3D;&#x3D;</p><p>some tips</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> kNumInts = <span class="number">5</span>;</span><br><span class="line"><span class="comment">// const is a promise to the compiler that this variable won’t change.</span></span><br><span class="line"><span class="keyword">using</span> <span class="type">vecsz_t</span> = std::vector&lt;<span class="type">int</span>&gt;::size_type; </span><br><span class="line"><span class="comment">// using let’s us use vecsz_t as an alias/synonym for the type std::vector&lt;int&gt;::size_type;</span></span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>vectors only grow efficiently in one direction</p><p><code>push_front()</code>  is impossible</p></blockquote><blockquote><p>&#x3D;&#x3D;deque&#x3D;&#x3D;</p><p>double ended queue, fast  <code>push_front()</code></p><p>one common implementation:</p><p><img src="D:\CS106L\CS106L.assets\image-20230116191549087.png" alt="image-20230116191549087"></p></blockquote><p><strong>So If deque can do everything a vector can do and also has a fast push_front…</strong></p><p><strong>Why use a vector at all?</strong></p><blockquote><p>Deques support fast push_front operations. However, for other common operations like element access, vector will always outperform a deque.</p></blockquote><p><strong>implementation of stacks and queue using vector or deque</strong></p><blockquote><p><code>push_back()</code> <code>push_back()</code></p><p><code>pop_back()</code>  <code>pop_front()</code></p></blockquote><h2 id="Lec4-Associative-Containers-and-Iterators"><a href="#Lec4-Associative-Containers-and-Iterators" class="headerlink" title="Lec4: Associative Containers and Iterators"></a>Lec4: Associative Containers and Iterators</h2><h3 id="Associative-Containers"><a href="#Associative-Containers" class="headerlink" title="Associative Containers"></a>Associative Containers</h3><blockquote><p>access data by key not index</p><p>● std::map&lt;T1, T2&gt; </p><p>● std::set<T> </p><p>● std::unordered_map&lt;T1, T2&gt; </p><p>● std::unordered_set<T></p></blockquote><h3 id="Iterators"><a href="#Iterators" class="headerlink" title="Iterators"></a>Iterators</h3><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for (int i = 0; i &lt; ???; i++)</span></span><br><span class="line"><span class="comment">// we don&#x27;t know the i should less than what if we want to iterate over the associative container</span></span><br><span class="line">set&lt;<span class="type">int</span>&gt; mySet;</span><br><span class="line">iterator iter = mySet.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>(iter != mySet.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; endl;</span><br><span class="line">    ++iter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure><p>● Create iterator </p><p>● Dereference iterator to read value currently pointed to </p><p>● Advance iterator </p><p>● Compare against another iterator (especially .end() iterator)</p></blockquote><h2 id="Lec5-Advanced-Associative-Containers"><a href="#Lec5-Advanced-Associative-Containers" class="headerlink" title="Lec5: Advanced Associative Containers"></a>Lec5: Advanced Associative Containers</h2><h3 id="Further-Usage"><a href="#Further-Usage" class="headerlink" title="Further Usage"></a>Further Usage</h3><blockquote><p>Sorting</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure><p>Finding elements</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator i = mySet.<span class="built_in">lower_bound</span>(<span class="number">7</span>); </span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator end = mySet.<span class="built_in">lower_bound</span>(<span class="number">26</span>); </span><br><span class="line"><span class="keyword">while</span> (i != end) &#123; </span><br><span class="line">    cout &lt;&lt; *i &lt;&lt; endl; </span><br><span class="line">    ++i; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for [a,b]<code>lower_bound(a)</code> is &gt;&#x3D; a<code>upper_bound(b)</code> is &lt;&#x3D; b</p></blockquote><h3 id="Multimap"><a href="#Multimap" class="headerlink" title="Multimap"></a>Multimap</h3><blockquote><p>we want to map the same key to different values</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;<span class="type">int</span>, <span class="type">int</span>&gt; myMMap; </span><br><span class="line">myMMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">3</span>)); </span><br><span class="line">myMMap.<span class="built_in">insert</span>(&#123;<span class="number">3</span>, <span class="number">12</span>&#125;); <span class="comment">// shorter syntax </span></span><br><span class="line">cout &lt;&lt; myMMap.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; endl; <span class="comment">// prints 2</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h3><blockquote><p>just think the map that store the deque of string and vector of string</p><p><code>map&lt;deque&lt;string&gt;, vector&lt;string&gt;&gt;</code></p><p>if we want to get its iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map&lt;deque&lt;string&gt;, vector&lt;string&gt;&gt;::iterator iter = map.<span class="built_in">begin</span>()</span><br></pre></td></tr></table></figure><p>it’s too tedious</p><p>so we want to clean this up, use alias ?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> NGramMap = map&lt;deque&lt;string&gt;, vector&lt;string&gt;&gt;;</span><br></pre></td></tr></table></figure><p>can we do better? Yes, the keyword <code>auto</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;deque&lt;string&gt;, vector&lt;string&gt;&gt; myMap; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = myMap.<span class="built_in">begin</span>(); iter != myMap.<span class="built_in">end</span>(); ++iter) &#123; </span><br><span class="line"><span class="built_in">doSomething</span>(*(iter).first, *(iter).second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A range based for loop is (more or less) a shorthand for iterator code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; myMap; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> thing : myMap) &#123; </span><br><span class="line">    <span class="built_in">doSomething</span>(thing.first, thing.second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; myMap; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = myMap. <span class="built_in">begin</span>(); iter != myMap. <span class="built_in">end</span>(); ++iter) &#123; </span><br><span class="line">    <span class="keyword">auto</span> thing = *iter; </span><br><span class="line">    <span class="built_in">doSomething</span> (thing.first, thing.second); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Lec6-Templates-and-Iterators"><a href="#Lec6-Templates-and-Iterators" class="headerlink" title="Lec6: Templates and Iterators"></a>Lec6: Templates and Iterators</h2><h3 id="Templates"><a href="#Templates" class="headerlink" title="Templates"></a>Templates</h3><blockquote><p>concern the function that choose the less among two numbers</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">min</span>(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">13</span>,<span class="number">8</span>); <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">1.9</span>,<span class="number">3.7</span>); <span class="comment">// ?</span></span><br></pre></td></tr></table></figure><p>so we should write a new function for the double_size</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">min</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>and the siez_t, float, char…?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">min_sizet</span><span class="params">(<span class="type">size_t</span> a, <span class="type">size_t</span> b)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">min_float</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">char</span> <span class="title">min_ch</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span> </span>&#123; </span><br><span class="line"> <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>it’s too tedious!</p><ul><li>Multiple copies of essentially the same function. </li><li>You need to write the type name whenever you use it </li><li>Every time you want to add a new type, you need to add a new function. </li><li>If you edit the function slightly, you need to edit it in each version manually</li></ul><p>we can use <strong>overloaded functions</strong> to avoid one of these problems</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">min</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">min</span>(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">min</span>(<span class="number">1.9</span>, <span class="number">5.7</span>); <span class="comment">// 1.9</span></span><br></pre></td></tr></table></figure><ul><li>Multiple copies of essentially the same function. </li><li><del>You need to write the type name whenever you use it</del> </li><li>Every time you want to add a new type, you need to add a new function. </li><li>If you edit the function slightly, you need to edit it in each version manually</li></ul><p>The solution: Templates</p><p>Templates are a blueprint of a function that let you use the same function for a variety of types:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> (a &lt; b) ? a : b; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = <span class="built_in">min</span>(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="Implicit-Interface"><a href="#Implicit-Interface" class="headerlink" title="Implicit Interface"></a>Implicit Interface</h3><blockquote><p>Any time template instantiation occurs, the compiler will check that all operations used on the templatised type are supported by that type.</p><p>What types are valid to use with a templatized function? </p><p>Any that satisfy its implicit interface.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">(T input)</span> </span>&#123; </span><br><span class="line">    <span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">if</span>(input &gt;&gt; i &amp;&amp; input.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">        input.<span class="built_in">push_back</span>(i); <span class="keyword">return</span> i; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="Templates-ft-Iterators"><a href="#Templates-ft-Iterators" class="headerlink" title="Templates ft. Iterators"></a>Templates ft. Iterators</h3><blockquote><p>Every different collection comes equipped with its own type of iterator:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>(); </span><br><span class="line">vector&lt;<span class="type">double</span>&gt; v; </span><br><span class="line">vector&lt;<span class="type">double</span>&gt;::iterator itr = v.<span class="built_in">begin</span>();</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d; </span><br><span class="line">deque&lt;<span class="type">int</span>&gt;::iterator itr = d.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure><p>The whole point of iterators was to have a standard interface to iterate over data in any container. </p><p>But we still had to specify what type of data this iterator was pointing to. </p><p>We want to ultimately write generic functions to work with iterators over any sequence. </p><p>With templates we can!</p></blockquote><h2 id="Lec7-Algorithms"><a href="#Lec7-Algorithms" class="headerlink" title="Lec7: Algorithms"></a>Lec7: Algorithms</h2><h3 id="Iterator-Types"><a href="#Iterator-Types" class="headerlink" title="Iterator Types"></a>Iterator Types</h3><blockquote><p>So far we have only really incremented iterators</p><p>But for some containers, we should be able to jump anywhere</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line"><span class="keyword">auto</span> mid = v.<span class="built_in">begin</span>() + v.<span class="built_in">size</span>()/<span class="number">2</span>; </span><br><span class="line"></span><br><span class="line"><span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">13</span>)</span></span>; </span><br><span class="line"><span class="keyword">auto</span> some_iter = d.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p>What about std::list(dllist)?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">myList</span><span class="params">(<span class="number">10</span>)</span></span>; </span><br><span class="line"><span class="keyword">auto</span> some_iter = myList.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br></pre></td></tr></table></figure><p><img src="D:\CS106L\CS106L.assets\image-20230129202426431.png" alt="image-20230129202426431"></p><p>There are 5 different types of iterators</p><ol><li><p>Input</p></li><li><p>Output</p></li><li><p>Forward</p></li><li><p>Bidirectional</p></li><li><p>Random access</p></li></ol><p>All iterators share a few common traits:</p><ul><li>Can be created from existing iterator</li><li>Can be advanced using ++</li><li>Can be compared with &#x3D;&#x3D; and !&#x3D;</li></ul><p><img src="D:\CS106L\CS106L.assets\image-20230129202942131.png" alt="image-20230129202942131"></p><ul><li><p>input and output are single-pass input</p><p>input can only be dereferenced on right side of expression</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = *itr;</span><br></pre></td></tr></table></figure><p>output can only be dereferenced on left side of expression</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*itr = <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>forward is same as input&#x2F;output except can make multiple passes</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = ... </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="type">int</span> val = *itr; </span><br><span class="line"><span class="type">int</span> val2 = *itr;</span><br></pre></td></tr></table></figure></li><li><p>bidirectional is same as forward except can also go backwards with decrement operator –</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = ... </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>(); </span><br><span class="line">++itr; </span><br><span class="line"><span class="type">int</span> val = *itr; </span><br><span class="line">--itr; </span><br><span class="line"><span class="type">int</span> val2 = *itr;</span><br></pre></td></tr></table></figure></li><li><p>Random access is same as bidirectional except can be incremented or decremented by arbitary amounts using + and -</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = ... </span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator itr = v.<span class="built_in">begin</span>(); </span><br><span class="line"><span class="type">int</span> val = *itr; </span><br><span class="line">itr = itr + <span class="number">3</span>; </span><br><span class="line"><span class="type">int</span> val2 = *itr;</span><br></pre></td></tr></table></figure></li></ul></blockquote><h3 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h3><blockquote><p>Abstraction in the STL</p><p>Basic Types → Containers → Iterators → Algorithms</p><p>Let’s look at the std::copy algorithm to get a better understanding of algorithms and iterators:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">561</span>, <span class="number">1105</span>, <span class="number">1729</span>, <span class="number">2465</span>&#125;; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vCopy</span><span class="params">(v.size())</span></span>; </span><br><span class="line">std::<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vCopy.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p>copy begin at vCopy.begin from v.begin to v.end</p><p>but what happen if vCopy don’t have enough space?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">561</span>, <span class="number">1105</span>, <span class="number">1729</span>, <span class="number">2465</span>&#125;; </span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vCopy</span><span class="params">(<span class="number">2</span>)</span></span>; </span><br><span class="line">std::<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), vCopy.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure><p><img src="D:\CS106L\CS106L.assets\image-20230129212922049.png" alt="image-20230129212922049"></p><p>We want to be able to copy into a collection by <strong>inserting</strong> into it, rather than making space for it first.</p></blockquote><h3 id="Iterator-Adapters"><a href="#Iterator-Adapters" class="headerlink" title="Iterator Adapters"></a>Iterator Adapters</h3><blockquote><p>Sometimes we need to form “weird” iterators:</p><ul><li>Iterating over streams would be pretty cool</li><li>Having an iterator that could “insert” into a collection would be pretty cool</li></ul><p><code>std::ostream_iterator</code></p><p>Look like output iterators</p><ul><li>Can be dereferenced with *</li><li>Can be advanced with ++</li></ul><p>Whenever you dereference a <code>std::ostream_iterator</code> and assign a value to it, the value is printed to a specified <code>std::ostream</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : nums) &#123;</span><br><span class="line">        cout &lt;&lt; elem &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;&#125;&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">iter</span><span class="params">(cout, <span class="string">&quot;, &quot;</span>)</span></span>;</span><br><span class="line">    *iter = <span class="number">15</span>;</span><br><span class="line">    ++iter;</span><br><span class="line">    *iter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vec&#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// full type is annoying to write so we&#x27;ll use auto</span></span><br><span class="line">    <span class="comment">// std::back_insert_iterator&lt;vector&lt;int&gt;&gt; it = std::back_inserter(vec);</span></span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">back_inserter</span>(vec);</span><br><span class="line"></span><br><span class="line">    *it = <span class="number">5</span>;</span><br><span class="line">    ++it;</span><br><span class="line">    *it = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printVector</span>(vec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run and we will get these</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">15, 1, </span><br><span class="line">&#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3, &#125;</span><br><span class="line">&#123;3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 12, &#125;</span><br></pre></td></tr></table></figure><p>Yes, it looks like you’re manipulating contents of a container, but really you’re writing characters to the cout stream.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v&#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>&#125;; </span><br><span class="line">std::<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot;, &quot;</span>))</span><br></pre></td></tr></table></figure><p>So we can solve the problem in last paragraph:</p><p><em><strong>We want to be able to copy into a collection by inserting into it, rather than making space for it first.</strong></em></p><p>The standard library provides insert iterators(<code>std::inserter</code> <code>std::back_inserter</code> <code>std::front_inserter</code>)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v &#123;<span class="number">561</span>, <span class="number">1105</span>, <span class="number">1729</span>, <span class="number">2465</span>&#125;; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vCopy; </span><br><span class="line">std::<span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(vCopy));</span><br></pre></td></tr></table></figure></blockquote>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2023/01/29/CS106L/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Test</title>
      <link>http://example.com/2022/12/29/Test/</link>
      <guid>http://example.com/2022/12/29/Test/</guid>
      <pubDate>Thu, 29 Dec 2022 13:27:33 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;Test&quot;&gt;&lt;a href=&quot;#Test&quot; class=&quot;headerlink&quot; title=&quot;Test&quot;&gt;&lt;/a&gt;Test&lt;/h1&gt;&lt;h2 id=&quot;Test-1&quot;&gt;&lt;a href=&quot;#Test-1&quot; class=&quot;headerlink&quot; title=&quot;Test&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Test-1"><a href="#Test-1" class="headerlink" title="Test"></a>Test</h2><h3 id="Test-2"><a href="#Test-2" class="headerlink" title="Test"></a>Test</h3><p>test</p>]]></content:encoded>
      
      
      <category domain="http://example.com/categories/test/">test</category>
      
      
      <category domain="http://example.com/tags/testMyBlog/">testMyBlog</category>
      
      
      <comments>http://example.com/2022/12/29/Test/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Hello World</title>
      <link>http://example.com/2022/12/29/hello-world/</link>
      <guid>http://example.com/2022/12/29/hello-world/</guid>
      <pubDate>Wed, 28 Dec 2022 16:04:35 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</description>
        
      
      
      
      <content:encoded><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content:encoded>
      
      
      
      
      <comments>http://example.com/2022/12/29/hello-world/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
